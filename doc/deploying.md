# Deploying Lambda Island Libraries

We have an internal tool to perform project management tasks for our libraries,
all projects that have been updated to make use of this tool will contain a
`bin/proj` file. This is a Clojure source file that is executed with Babashka.
You will also find a `bin/bb` wrapper script for Babashka, which automatically
installed if it is not yet installed, and a `bb_deps.edn`, which contains
babashka-specific dependencies. In particular you will find
`lambdaisland/open-source`, which contains the `lioss.*` namespaces used by
`bin/proj`.

This is what a minimal `bin/proj` looks like. This is for `deep-diff2`.

``` clojure
#!bin/bb

(ns proj 
  (:require [lioss.main :as lioss]))

(lioss/main
 {:license        :epl
  :inception-year 2018
  :description    "Recursively compare Clojure or ClojureScript data structures, and produce a colorized diff of the result."})
```

This script can perform various tasks:

```
$ bin/proj
Usage: bin/proj [COMMAND] [COMMAND_ARGS...]

  update-docs                        Update the ToC and version strings in md files
  release                            Release a new version to clojars
  pom                                Generate pom files
  install                            Build and install jar(s) locally
  gh_actions_changelog_output        Print the last stanza of the changelog in a format that GH actions understands
  help                               Show this help information
  inspect                            Show expanded opts and exit
  gen-readme                         Generate README based on a template and fill in project variables
  update-readme                      Update sections in README.md
```

Depending on the project there may be extra tasks, there may also be hooks to
perform extra steps as part of the release process, for instance pre-compiling
assets like Java files, CSS, etc.

Some projects are split across multiple "modules", which are released as
separate jars. For example `chui` consists of `chui-ui`, `chui-core`,
`chui-remote`, etc. Our tooling contains various smarts to deal with this, and
to do coordinated releases of all modules in a project.

Here is a more elaborate `bin/proj`, which defines an extra task and release
hook, and defines several submodules.

```
#!bin/bb

(ns proj
  (:require [clojure.java.shell :as sh]
            [lioss.main :as lioss]
            [lioss.shellutil :as shellutil]))

(defn gen-styles [opts]
  (println "Generating  modules/chui-ui/release/lambdaisland/chui/styles.clj")
  (shellutil/mkdir-p "modules/chui-ui/release/lambdaisland/chui/")
  (spit "modules/chui-ui/release/lambdaisland/chui/styles.clj"
        (str "(ns lambdaisland.chui.styles)\n"
             ";; Auto-generated by bin/proj\n"
             "(defmacro inline []\n"
             (:out (sh/sh "clojure" "-A:dev" "-e" "(require 'lambdaisland.chui.styles) (prn (lambdaisland.chui.styles/inline))"))
             ")"))
  opts)

(lioss/main
 {:license        :epl
  :inception-year 2020
  :description    "Modern ClojureScript test runner"
  :pre-release-hook gen-styles
  :modules [{:name        "chui-core"
             :description "ClojureScript Test Runner Core"}
            {:name        "chui-ui"
             :description "Browser UI for the Chui test runner"}
            {:name        "chui-remote"
             :description "Funnel client for connecting test tooling to ClojureScript runtimes"}
            {:name        "chui-shadow"
             :description "Chui-based test runner namespaces to be used with Shadow-cljs"}]
  :commands ["styles"
             {:description "Generate inlined CSS from Garden"
              :command gen-styles}]})
```

## Versioning

The versioning scheme we use is `major.minor.revision`, where `revision` is the
number of git commits, and the `major.minor` version is set by adding a
`.VERSION_PREFIX` file to the repo. It defaults to `0.0`. Most of the time you
don't have to worry about versioning, it is done automatically.

## `bin/proj pom`

This generates the `pom.xml` file used by Maven (`mvn`), based on `deps.edn` and
the definitions in `bin/proj`, and `.VERSION_PREFIX`. Actually building jars and
releasing them is done with Maven under the hood. So make sure you have Maven
installed. The release task will implicitly generate the pom so you don't
normally need to do this yourself, but sometimes it's useful to inspect it, or
for invoking Maven manually.

``` shell
$ which mvn
/usr/bin/mvn

$ mvn --version
Apache Maven 3.6.3
Maven home: /usr/share/maven
Java version: 11.0.7, vendor: GraalVM Community, runtime: /home/arne/opt/graalvm-ce-java11-20.1.0
Default locale: en_US, platform encoding: UTF-8
OS name: "linux", version: "5.4.0-53-generic", arch: "amd64", family: "unix"
```

## `bin/proj install`

Create the release artifact (JAR) and install it in the local Maven cache. (`~/.m2`)

## `bin/proj release`

Create a release and push it to Clojars. Make sure you are set up to release to
Clojars, i.e. that you have access to the `lambdaisland` group on Clojars, and
that you have a deploy token set up. You should have something like this in
`~/.m2/settings.xml`.

- See [Clojars Deploy Tokens](https://github.com/clojars/clojars-web/wiki/Deploy-Tokens)

``` xml
<settings xmlns="http://maven.apache.org/SETTINGS/1.0.0"
          xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
          xsi:schemaLocation="http://maven.apache.org/SETTINGS/1.0.0
                 https://maven.apache.org/xsd/settings-1.0.0.xsd">
  <servers>

    <server>
      <id>clojars</id>
      <username>your_username</username>
      <password>clojars_deployment_token</password>
    </server>


  </servers>
</settings>
```

You also need a Github access token handy to create a release or need to configure `hub`. 

Or fake a hub config like  ` echo "oauth_token: $GHTOKEN" >> ~/.config/hub`

`bin/proj release` will do a bunch of things

- Update the pom
- Create a release JAR and push
- Update the CHANGELOG (add new version header)
- Tag the new version in git
- Commit and push the pom and changelog changes
- Trigger a cljdoc build

And this potentially recursively for modules.

If you encounter gpg related troubles, you probably need to first setup the gpg program properly.

- See [Setup gpg](./gpg.md)

## Updating `bb_deps.edn`

`bb_deps.edn` usually looks like this

``` clojure
{:deps
 {lambdaisland/open-source {:git/url "https://github.com/lambdaisland/open-source"
                            :sha "bdeb15d185e4f82ef9a07676076b23be11c0e0a1"}}}
```

Although it may look like this

``` clojure
{:deps {lambdaisland/open-source {:local/root "../open-source}}}
```

Assuming that you have `lambdaisland/open-source` checked out in the same
directory where the project itself is checked out. Before performing tasks on a
project it's a good idea to make sure it is pointing at the most recent git
commit for `lambdaisland/open-source` (please feel free to automate this).

## Readme management

Our READMEs contain sections which are named with HTML comments like this:

``` HTML
<!-- opencollective -->

## Support Lambda Island Open Source

...

<!-- /opencollective -->
```

These are generated using templates configured in the `lambdaisland/open-source`
project (look for `README_sections.md`). We understand these sections:

- badges
- opencollective
- installation
- contributing
- license-epl
- license-mpl

This allows us to manage the READMEs of our dozen or so projects in a consistent
way. You should not edit these sections in the respective projects directly,
instead update the template and run `bin/proj update-readme`.

If you are starting a new project or overhauling/redoing the README, you can run
`bin/proj gen-readme` to get a starting point with all the major sections.
